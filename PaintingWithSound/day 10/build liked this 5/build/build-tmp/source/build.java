/* autogenerated by Processing revision 1283 on 2022-07-25 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import hype.*;
import hype.extended.behavior.HOscillator;
import hype.extended.layout.HGridLayout;
import ddf.minim.*;
import ddf.minim.analysis.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class build extends PApplet {





int         stageW           = 1000;
int         stageH           = 1000;
int       clrBG            = 0xFF242424;
String      pathAssets       = "../../../assets/";

// ************************************************************************************

// THIS IS THE AUDIO VARS




Minim       minim;
AudioPlayer myAudioPlayer;
String      whichAudioFile   = "DM2.mp3";

AudioInput  myAudioInput;
boolean     myAudioToggle    = true; // true = myAudioPlayer / false = myAudioInput
boolean     showVisualizer   = true;

FFT         myAudioFFT;

int         myAudioRange     = 16; // 256 / 128(2) / 64(4) / 32(8) / 16(16)
int         myAudioMax       = 100;

float       myAudioAmp;
float       myAudioIndex;
float       myAudioIndexAmp;
float       myAudioIndexStep;

float[]     myAudioData      = new float[myAudioRange]; // KEEP A RECORD OF ALL THE NUMBERS IN AN ARRAY

// ************************************************************************************

// THIS ALL THE WORKING WITH COLOR STUFF

String      whichImg         = pathAssets + "rainbow.png";
PImage      clrs;
int         clrsW;
float       clrCount;
float       clrSpeed         = 0.02f; // the speed of the color change
float       clrOffset        = 0.02f; // the distance from each of the squares getting colored

// ************************************************************************************

// VARS TO RENDER SOME IMAGES

boolean     letsRender       = false; // RENDER YES OR NO
int         renderModulo     = 120;    // RENDER AN IMAGE ON WHAT TEMPO ?
int         renderNum        = 0;     // FIRST IMAGE
int         renderMax        = 20;    // HOW MANY IMAGES
String      renderPATH       = "../renders_001/";

// ************************************************************************************

int gridCols = 10;
int gridRows = 10;
int gridDepth = 10;

int gridTotal = gridCols * gridRows *gridDepth;

int gridSpaceX = 1000;
int gridSpaceY = 1000;//spacing between cells Y
int gridSpaceZ = 1000;//spacing between cells Y

int gridStartX = -((gridCols-1)*(gridSpaceX/2));
int gridStartY = -((gridRows-1)*(gridSpaceY/2));// where to start grid
int gridStartZ = -((gridDepth-1)*(gridSpaceZ/2));// where to start grid


HGridLayout layout;
PVector[] pos = new PVector[gridTotal];

// ************************************************************************************

HOscillator[] oscX = new HOscillator[gridTotal];
HOscillator[] oscY = new HOscillator[gridTotal];
HOscillator[] oscZ = new HOscillator[gridTotal];
HOscillator[] oscRX = new HOscillator[gridTotal];
HOscillator[] oscRY = new HOscillator[gridTotal];
HOscillator[] oscRZ = new HOscillator[gridTotal];


// ************************************************************************************
//LOAD IN THE TEXTURES

String[] texNames = {"square.png","square.png","square.png","square.png","square.png","square.png"};
int  texNamesLen  = texNames.length;
PImage[]  tex     = new PImage[texNamesLen];

// ************************************************************************************

 public void settings() {
  size(stageW, stageH, P3D);
}

 public void setup() {
  H.init(this);
  background(clrBG);
  audioSetup();

  clrs = loadImage(whichImg);
  clrsW = clrs.width-1;


  for (int i = 0; i < texNamesLen; ++i) {
    tex[i] = loadImage(pathAssets + texNames[i]);
    }
    textureMode(NORMAL);

    //BUIL THE GRID AND THE OSCILLATORS
    layout = new HGridLayout().startLoc(gridStartX,gridStartY,gridStartZ).spacing(gridSpaceX,gridSpaceY,gridSpaceZ).cols(gridCols).rows(gridRows);
    for (int i = 0; i < gridTotal; ++i) {
    pos[i] = new PVector();
    pos[i] = layout.getNextPoint();

     oscX[i]  = new HOscillator().range(-300, 300).speed(1).freq(1).currentStep(i*5).waveform(H.SINE);
     oscY[i]  = new HOscillator().range(-300, 300).speed(1).freq(1).currentStep(i*5).waveform(H.SINE);
     oscZ[i]  = new HOscillator().range(-600, 300).speed(1).freq(1).currentStep(i*5).waveform(H.SINE);
     oscRX[i]  = new HOscillator().range(-180, 180).speed(1).freq(1).currentStep(i*5).waveform(H.SINE);
     oscRY[i]  = new HOscillator().range(-180, 180).speed(1).freq(1).currentStep(i*5).waveform(H.SINE);
     oscRZ[i]  = new HOscillator().range(-180, 180).speed(1).freq(1).currentStep(i*5).waveform(H.SINE);

 }
}

 public void draw() {
  background( clrBG );

// ************************************************************************************

  //strokeWeight(1);
  //stroke(#000000);


 //lights();

  push();
    translate(stageW/2, stageH/2, 0);
    for (int i = 0; i < gridTotal; ++i) {
      HOscillator _oscX = oscX[i];
      float _aX = map(myAudioData[1],0,myAudioMax,0.0f,2.0f);
      _oscX.speed(_aX+ (i * 0.005f));
      _oscX.nextRaw();

      HOscillator _oscY = oscY[i];
      float _aY = map(myAudioData[3],0,myAudioMax,0.0f,2.0f);
      _oscY.speed(_aY+ (i * 0.005f));
      _oscY.nextRaw();

      HOscillator _oscZ = oscZ[i];
      float _aZ = map(myAudioData[0],0,myAudioMax,0.1f,2.0f);
      _oscZ.speed(_aZ+ (i * 0.005f));
      _oscZ.nextRaw();

      HOscillator _oscRX = oscRX[i];
      float _aRX = map(myAudioData[2],0,myAudioMax,0.0f,1.75f);
      _oscRX.speed(_aRX+ (i * 0.005f));
      _oscRX.nextRaw();

      HOscillator _oscRY = oscRY[i];
      float _aRY = map(myAudioData[4],0,myAudioMax,0.0f,1.5f);
      _oscRY.speed(_aRY+ (i * 0.005f));
      _oscRY.nextRaw();

      HOscillator _oscRZ = oscRZ[i];
      float _aRZ = map(myAudioData[6],0,myAudioMax,0.0f,1.25f);
      _oscRZ.speed(_aRZ+ (i * 0.005f));
      _oscRZ.nextRaw();

      push();
        translate(pos[i].x + _oscX.curr(), pos[i].y + _oscY.curr(), pos[i].z + _oscZ.curr());

        scale(150);

        rotateX(radians(_oscRX.curr()));
        rotateY(radians(_oscRY.curr()));
        rotateZ(radians(_oscRZ.curr()));

          float wave = sin( clrCount+(i*clrOffset) );
          float waveMap = map(wave, -1, 1, 0, clrsW);
          tint( clrs.get((int)waveMap,0), 255 );


        buildCube(tex[0],tex[1],tex[2],tex[3],tex[4],tex[5]);
      pop();
  }
  pop();

  

// ************************************************************************************

  noLights();
  audioUpdate();
  clrCount += clrSpeed;

  if(frameCount%(renderModulo)==0 && letsRender) {
    save(renderPATH + renderNum + ".png");
    renderNum++;
    if(renderNum>=renderMax) exit();
  }
}

// ************************************************************************************

 public void keyPressed() {
  switch (key) {
    case '1': if(!myAudioToggle){myAudioInput.close();} myAudioToggle = true;  minim.stop(); audioSetup(); break; // audioPlayer
    case '2': if(myAudioToggle){myAudioPlayer.close();} myAudioToggle = false; minim.stop(); audioSetup(); break; // audioInputcase 's': myAudioPlayer.pause();  break;
    case 'p': myAudioPlayer.play();   break;
    case 'm': myAudioPlayer.mute();   break;
    case 'u': myAudioPlayer.unmute(); break;

    case 'v': showVisualizer = !showVisualizer; break;
  }
}

// ************************************************************************************

 public void buildCube(PImage _t1, PImage _t2, PImage _t3, PImage _t4, PImage _t5, PImage _t6) {
  strokeWeight(0);
  noStroke();

  // back
  beginShape(QUADS);
    texture(_t3);
    vertex( (0.5f), -(0.5f), -(0.5f),   0, 0);
    vertex(-(0.5f), -(0.5f), -(0.5f),   1, 0);
    vertex(-(0.5f),  (0.5f), -(0.5f),   1, 1);
    vertex( (0.5f),  (0.5f), -(0.5f),   0, 1);
  endShape(CLOSE);

  // left
  beginShape(QUADS);
    texture(_t4);
    vertex(-(0.5f), -(0.5f), -(0.5f),   0, 0);
    vertex(-(0.5f), -(0.5f),  (0.5f),   1, 0);
    vertex(-(0.5f),  (0.5f),  (0.5f),   1, 1);
    vertex(-(0.5f),  (0.5f), -(0.5f),   0, 1);
  endShape(CLOSE);

  // right
  beginShape(QUADS);
    texture(_t2);
    vertex( (0.5f), -(0.5f),  (0.5f),   0, 0);
    vertex( (0.5f), -(0.5f), -(0.5f),   1, 0);
    vertex( (0.5f),  (0.5f), -(0.5f),   1, 1);
    vertex( (0.5f),  (0.5f),  (0.5f),   0, 1);
  endShape(CLOSE);

  // top
  beginShape(QUADS);
    texture(_t5);
    vertex(-(0.5f), -(0.5f), -(0.5f),   0, 0);
    vertex( (0.5f), -(0.5f), -(0.5f),   1, 0);
    vertex( (0.5f), -(0.5f),  (0.5f),   1, 1);
    vertex(-(0.5f), -(0.5f),  (0.5f),   0, 1);
  endShape(CLOSE);

  // bottom
  beginShape(QUADS);
    texture(_t6);
    vertex(-(0.5f),  (0.5f),  (0.5f),   0, 0);
    vertex( (0.5f),  (0.5f),  (0.5f),   1, 0);
    vertex( (0.5f),  (0.5f), -(0.5f),   1, 1);
    vertex(-(0.5f),  (0.5f), -(0.5f),   0, 1);
  endShape(CLOSE);

  // front
  beginShape(QUADS);
    texture(_t1);
    vertex(-(0.5f), -(0.5f),  (0.5f),   0, 0); // x, y, z, u, v
    vertex( (0.5f), -(0.5f),  (0.5f),   1, 0); // x, y, z, u, v
    vertex( (0.5f),  (0.5f),  (0.5f),   1, 1); // x, y, z, u, v
    vertex(-(0.5f),  (0.5f),  (0.5f),   0, 1); // x, y, z, u, v
  endShape(CLOSE);
}
// ************************************************************************************

// THIS IS THE VARS FOR THE RECTS IN THE VISUALIZER

float visX = 1.0f;
float visY = 1.0f;
float visW = ((PApplet.parseFloat(stageW)-(visX*2))-(PApplet.parseFloat(myAudioRange)-1)) / PApplet.parseFloat(myAudioRange);
float visH = 2.0f;
float visS = (PApplet.parseFloat(stageW)-(visX*2)) / PApplet.parseFloat(myAudioRange);

// ************************************************************************************

 public void audioSetup() {
	switch (myAudioRange) {
		case 16 :
			myAudioAmp       = 40.0f;
			myAudioIndex     = 0.2f;
			myAudioIndexStep = 0.30f;
			break;
		case 32 :
			myAudioAmp       = 30.0f;
			myAudioIndex     = 0.17f;
			myAudioIndexStep = 0.225f;
			break;
		case 64 :
			myAudioAmp       = 25.0f;
			myAudioIndex     = 0.125f;
			myAudioIndexStep = 0.175f;
			break;
		case 128 :
			myAudioAmp       = 30.0f;
			myAudioIndex     = 0.075f;
			myAudioIndexStep = 0.05f;
			break;
		case 256 : default :
			myAudioAmp       = 20.0f;
			myAudioIndex     = 0.05f;
			myAudioIndexStep = 0.025f;
			break;
	}
	myAudioIndexAmp  = myAudioIndex;

	minim = new Minim(this);

	if (myAudioToggle) {
		myAudioPlayer = minim.loadFile(pathAssets + whichAudioFile);
		myAudioPlayer.loop();
		// myAudioPlayer.mute();
		myAudioFFT = new FFT(myAudioPlayer.bufferSize(), myAudioPlayer.sampleRate());
		myAudioFFT.linAverages(myAudioRange);
		myAudioFFT.window(FFT.GAUSS);
	} else {
		myAudioInput = minim.getLineIn(Minim.MONO);
		myAudioFFT = new FFT(myAudioInput.bufferSize(), myAudioInput.sampleRate());
		myAudioFFT.linAverages(myAudioRange);
		myAudioFFT.window(FFT.NONE);
	}

}

// ************************************************************************************

 public void audioUpdate() {
	hint(DISABLE_DEPTH_TEST);
	noLights();
	perspective(PI/3.0f, (float)(width*2)/(height*2), 0.1f, 1000000);

	if (myAudioToggle) myAudioFFT.forward(myAudioPlayer.mix);
	else               myAudioFFT.forward(myAudioInput.mix);

	if(showVisualizer) {
		strokeWeight(0);
		noStroke();
		fill(0xFF000000, 245);
		rect(visX, visY, stageW, myAudioMax+30);
	}

	for (int i = 0; i < myAudioRange; ++i) {
		strokeWeight(0);
		noStroke();

		float tempIndexAvg = (myAudioFFT.getAvg(i) * myAudioAmp) * myAudioIndexAmp;
		myAudioIndexAmp+=myAudioIndexStep;
		float tempIndexCon = constrain(tempIndexAvg, 0, myAudioMax);
		myAudioData[i]     = tempIndexCon; // RECODE THE NUMBERS FROM - 0 TO 100

		if (showVisualizer) {
			if(tempIndexCon<=visH)                         fill(0xFF333333); // NO AUDIO
			else if(tempIndexCon>visH && tempIndexCon<=10) fill(0xFF2EA893); // visH to 10
			else if(tempIndexCon>10 && tempIndexCon<=20)   fill(0xFF64BE7A); // 11 to 20
			else if(tempIndexCon>20 && tempIndexCon<=30)   fill(0xFF9AD561); // 21 to 30
			else if(tempIndexCon>30 && tempIndexCon<=40)   fill(0xFFCCEA4A); // 31 to 40
			else if(tempIndexCon>40 && tempIndexCon<=50)   fill(0xFFFFFF33); // 41 to 50
			else if(tempIndexCon>50 && tempIndexCon<=60)   fill(0xFFF8EF33); // 51 to 60
			else if(tempIndexCon>60 && tempIndexCon<=70)   fill(0xFFFFC725); // 61 to 70
			else if(tempIndexCon>70 && tempIndexCon<=80)   fill(0xFFFF9519); // 71 to 80
			else if(tempIndexCon>80 && tempIndexCon<=90)   fill(0xFFFF620C); // 81 to 90
			else                                           fill(0xFFFF3300); // 91 to 100

			rect( visX + (i*visS), ((visY-(visH/2))+(myAudioMax/2))-(tempIndexCon/2), visW, visH+tempIndexCon);

			textSize(14);
			text( (int)myAudioData[i], visX + (i*visS), visY+(myAudioMax+20) );

			strokeWeight(1);
			stroke(0xFF666666);
			noFill();
			line(0, visY, stageW, visY);
			line(0, visY+myAudioMax, stageW, visY+myAudioMax);
			line(0, visY+(myAudioMax+30), stageW, visY+(myAudioMax+30));
		}
	}
	myAudioIndexAmp = myAudioIndex;
	hint(ENABLE_DEPTH_TEST);
}

// ************************************************************************************

 public void stop() {
	if (myAudioToggle) myAudioPlayer.close();
	else               myAudioInput.close();
	minim.stop();  
	super.stop();
}

// ************************************************************************************


  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "build" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
