/* autogenerated by Processing revision 1283 on 2022-07-29 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import hype.*;
import hype.extended.behavior.HOscillator;
import hype.extended.layout.HPolarLayout;
import hype.extended.behavior.HOrbiter3D;
import ddf.minim.*;
import ddf.minim.analysis.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class build extends PApplet {






int         stageW         = 1920;
int         stageH         = 1080;
int       clrBG          = 0xFF242424;
String      pathAssets     = "../../../assets/";

// ************************************************************************************

// THIS IS THE AUDIO VARS




Minim       minim;
AudioPlayer myAudioPlayer;
String      whichAudioFile = "bring_me_the_horizon_oh_no.mp3"; //2pt
/*String      whichAudioFile = "asking_alexandria_the_death_of_me.mp3"; 2pts
/*String      whichAudioFile = "french_79_hometown.mp3";*/		//+2-1pt

AudioInput  myAudioInput;
boolean     myAudioToggle  = true; // true = myAudioPlayer / false = myAudioInput
boolean     showVisualizer = false;

FFT         myAudioFFT;

int         myAudioRange   = 16; // 256 / 128(2) / 64(4) / 32(8) / 16(16)
int         myAudioMax     = 100;

float       myAudioAmp;
float       myAudioIndex;
float       myAudioIndexAmp;
float       myAudioIndexStep;

float[]     myAudioData    = new float[myAudioRange]; // KEEP A RECORD OF ALL THE NUMBERS IN AN ARRAY

// ************************************************************************************

// THIS ALL THE WORKING WITH COLOR STUFF

String      whichImg       = pathAssets + "colorsM_02.png";
PImage      clrs;
int         clrsW;
float       clrCount;
float       clrSpeed       = 0.02f; // the speed of the color change
float       clrOffset      = 0.0025f; // the distance from each of the squares getting colored

// ************************************************************************************
// THIS ALL THE WORKING WITH COLOR STUFF for pyreflies

String      whichImgP       = pathAssets + "colorsM_01.png";
PImage      clrs2;
int         clrsW2;
float       clrCount2;
float       clrSpeed2       = 0.02f; // the speed of the color change
float       clrOffset2     = 0.0025f; // the distance from each of the squares getting colored

// ************************************************************************************

// VARS TO RENDER SOME IMAGES

boolean     letsRender     = false; // RENDER YES OR NO
int         renderModulo   = 120;    // RENDER AN IMAGE ON WHAT TEMPO ?
int         renderNum      = 0;     // FIRST IMAGE
int         renderMax      = 20;    // HOW MANY IMAGES
String      renderPATH     = "../renders_002/";

// ************************************************************************************

// LOAD IN A TEXTURES TO MAP TO A SPRITE

// back / left / right / top / bottom / front

String[]    texNames       = { "gcg.png", "gcg.png", "gcg.png", "gcg.png", "gcg.png", "gcg.png" };
int         texNamesLen    = texNames.length;
PImage[]    tex            = new PImage[texNamesLen];

// LOAD IN A TEXTURES TO MAP THE SPRITS

String[]    texNames2       = { "particle_00.png" };
int         texNamesLen2    = texNames2.length;
PImage[]    tex2            = new PImage[texNamesLen2];


// *********************************************************************************************

int         numAssets      = 1100;

int         layoutOffsetX   = 0;
int         layoutOffsetY   = 0;

HPolarLayout layout;

PVector[]   pos            = new PVector[numAssets];

// *********************************************************************************************

HOscillator masterRZ;
HOscillator masterRX;

HOscillator[] oscZ         = new HOscillator[numAssets];
HOscillator[] oscS         = new HOscillator[numAssets];

// *********************************************************************************************

int[]       myPickedAudio  = new int[numAssets];

// *********************************************************************************************
//Static rose window for the Polar window effect
PImage roseWindow;
float startRosPosX = 0.0f;
float startRosPosY = 0.0f;

// *********************************************************************************************
	// cooldown counter for the effect switching;
	int cooldowncnt = 0; 

// *********************************************************************************************

boolean delayTimer = false;
int delayBase = 300;
int delayCount = delayBase;


// *********************************************************************************************

//array of functions
	interface magic{
		void spell();
	}


	magic[] magics = new magic[]{
		new magic() {public void spell(){drawMusic();}   },
		new magic() {public void spell(){drawPolarWindow();}},
		new magic() {public void spell(){drawPyreflies();}}
	};
	int magicNumber = 2;
// *********************************************************************************************

 public void settings() {
	size(stageW, stageH, P3D);
	// fullScreen();
}

 public void setup() {
	H.init(this);
	background(clrBG);
	audioSetup();

	roseWindow = loadImage(pathAssets + "csg.png");

	clrs = loadImage(whichImg);
	clrsW = clrs.width-1;

	// LOAD THE TEXTURES
	for (int i = 0; i < texNamesLen; ++i) {
		tex[i] = loadImage(pathAssets + texNames[i]);
	}
	textureMode(NORMAL);

	// BUILD THE POLAR and OSC
	layout = new HPolarLayout(1, 0.2f).offsetX(layoutOffsetX).offsetY(layoutOffsetY);

	for (int i = 0; i < numAssets; ++i) {
		pos[i] = layout.getNextPoint();
		myPickedAudio[i] = (int)random(12);
		// myPickedAudio[i] = i%12;

		oscZ[i]  = new HOscillator().range(-2000, 100).speed(1).freq(5).currentStep(i*0.5f).waveform(H.SINE);
		oscS[i]  = new HOscillator().range(0.02f, 0.2f).speed(1).freq(10).currentStep(i).waveform(H.SINE);
	}
	masterRZ = new HOscillator().range(-180, 180).speed(0.1f).freq(0.7f).waveform(H.SINE);
	/*pyreflies*/
	clrs2 = loadImage(whichImgP);
	clrsW2 = clrs2.width-1;

	// LOAD THE TEXTURES
	for (int i = 0; i < texNamesLen2; ++i) {
		tex2[i] = loadImage(pathAssets + texNames2[i]);
	}
	textureMode(NORMAL);

	// BUILD THE 3D ORBITER and OSC

	for (int i = 0; i < numAssets2; ++i) {
		orb[i] = new HOrbiter3D()
			.startX(orbStartX)
			.startY(orbStartY)
			.startZ(orbStartZ)
			.zSpeed( random(orbZ_SpeedMin, orbZ_SpeedMax) )
			.ySpeed( random(orbY_SpeedMin, orbY_SpeedMax) )
			.radius(orbRadius)
			.zAngle( (int)random(360) )
			.yAngle( (int)random(360) )
			// .zAngle( (i*5)%360 )
			// .yAngle( (i*5)%360 )
			// .zAngle( 0 )
			// .yAngle( 0 )
		;

		myPickedAudio[i] = (int)random(12);

		oscS2[i]  = new HOscillator().range(50, 200).speed(1).freq(5).currentStep(i*5).waveform(H.SINE);
	}
	/*pyreflies end*/
}
	
 public void draw() {
	//background( clrBG );
	

// ************************************************************************************
//HERE I DRAW THE FUCNTIONS\\
		magics[magicNumber].spell();
	if( myAudioData[5]>=90 && !delayTimer) {
		delayTimer = true;
		magicNumber = (int)random(magics.length);
		println("fucker");
	}
	if(delayTimer) delayCount--;
	if(delayCount<=0) {
		delayCount = delayBase;
		delayTimer = false;
	}

	// if(myAudioData[5]>=90 && cooldowncnt == 0){
	// 	int cnt = 1;
	// 	cooldowncnt=25;
	// 	if (cnt == 1) {
	// 		magics[1].spell();
	// 		cnt--;
		
	// 	} else{
	// 		magics[0].spell();
	// 		cnt++;	
	// 	}
	// }
	// cooldowncnt--;

	// if (cooldowncnt < 0 ) {
	// 	cooldowncnt = 0;
	// }

	//magics[1].spell();
	//drawPolarWindow();
	//drawMusic();
// ************************************************************************************

	noLights();
	audioUpdate();
	clrCount += clrSpeed;

	if(frameCount%(renderModulo)==0 && letsRender) {
		save(renderPATH + renderNum + ".png");
		renderNum++;
		if(renderNum>=renderMax) exit();
	}
}



// ************************************************************************************

 public void keyPressed() {
	switch (key) {
		case '1': if(!myAudioToggle){myAudioInput.close();} myAudioToggle = true;  minim.stop(); audioSetup(); break; // audioPlayer
		case '2': if(myAudioToggle){myAudioPlayer.close();} myAudioToggle = false; minim.stop(); audioSetup(); break; // audioInput

		case 's': myAudioPlayer.pause();  break;
		case 'p': myAudioPlayer.play();   break;
		case 'm': myAudioPlayer.mute();   break;
		case 'u': myAudioPlayer.unmute(); break;

		case 'v': showVisualizer = !showVisualizer; break;
	}
}

// ************************************************************************************

 public void buildCube(PImage _t1, PImage _t2, PImage _t3, PImage _t4, PImage _t5, PImage _t6) {
	strokeWeight(0);
	noStroke();

	// back
	beginShape(QUADS);
		texture(_t1);
		vertex( (0.5f), -(0.5f), -(0.5f),   0, 0);
		vertex(-(0.5f), -(0.5f), -(0.5f),   1, 0);
		vertex(-(0.5f),  (0.5f), -(0.5f),   1, 1);
		vertex( (0.5f),  (0.5f), -(0.5f),   0, 1);
	endShape(CLOSE);

	// left
	beginShape(QUADS);
		texture(_t2);
		vertex(-(0.5f), -(0.5f), -(0.5f),   0, 0);
		vertex(-(0.5f), -(0.5f),  (0.5f),   1, 0);
		vertex(-(0.5f),  (0.5f),  (0.5f),   1, 1);
		vertex(-(0.5f),  (0.5f), -(0.5f),   0, 1);
	endShape(CLOSE);

	// right
	beginShape(QUADS);
		texture(_t3);
		vertex( (0.5f), -(0.5f),  (0.5f),   0, 0);
		vertex( (0.5f), -(0.5f), -(0.5f),   1, 0);
		vertex( (0.5f),  (0.5f), -(0.5f),   1, 1);
		vertex( (0.5f),  (0.5f),  (0.5f),   0, 1);
	endShape(CLOSE);

	// top
	beginShape(QUADS);
		texture(_t4);
		vertex(-(0.5f), -(0.5f), -(0.5f),   0, 0);
		vertex( (0.5f), -(0.5f), -(0.5f),   1, 0);
		vertex( (0.5f), -(0.5f),  (0.5f),   1, 1);
		vertex(-(0.5f), -(0.5f),  (0.5f),   0, 1);
	endShape(CLOSE);

	// bottom
	beginShape(QUADS);
		texture(_t5);
		vertex(-(0.5f),  (0.5f),  (0.5f),   0, 0);
		vertex( (0.5f),  (0.5f),  (0.5f),   1, 0);
		vertex( (0.5f),  (0.5f), -(0.5f),   1, 1);
		vertex(-(0.5f),  (0.5f), -(0.5f),   0, 1);
	endShape(CLOSE);

	// front
	beginShape(QUADS);
		texture(_t6);
		vertex(-(0.5f), -(0.5f),  (0.5f),   0, 0); // x, y, z, u, v
		vertex( (0.5f), -(0.5f),  (0.5f),   1, 0); // x, y, z, u, v
		vertex( (0.5f),  (0.5f),  (0.5f),   1, 1); // x, y, z, u, v
		vertex(-(0.5f),  (0.5f),  (0.5f),   0, 1); // x, y, z, u, v
	endShape(CLOSE);
}
// ************************************************************************************


 public void drawMusic(){
	showVisualizer = true;
	for (int i = 0; i < stageH/4; ++i) {
		audioUpdate();
		translate(0,(0.5f+i));
		audioUpdate();
	}
}
 public void drawPolarWindow(){
	showVisualizer=false;
	masterRZ.nextRaw();

	push();
		translate(stageW/2, stageH/2, 0);
		perspective(PI/3.0f, (float)(width*2)/(height*2), 0.1f, 1000000);
		rotateZ(radians(masterRZ.curr()));

		for (int i = 0; i < numAssets; ++i) {

			HOscillator _oscZ = oscZ[i];
			float _aZ = map(myAudioData[ 0 ], 0, myAudioMax, 0.2f, 1.0f);
			_oscZ.speed(_aZ);
			_oscZ.nextRaw(); 

			HOscillator _oscS = oscS[i];
			float _aS = map(myAudioData[ myPickedAudio[i] ], 0, myAudioMax, 0.05f, 2.0f);
			_oscS.speed(_aS);
			_oscS.nextRaw(); 

			push();
				translate(pos[i].x, pos[i].y, pos[i].z + _oscZ.curr() );
				float d = dist(layout.offsetX(), layout.offsetY(), pos[i].x, pos[i].y);
				scale(d * _oscS.curr() );

				float wave = sin( clrCount+(i*clrOffset) );
				float waveMap = map(wave, -1, 1, 0, clrsW);
				tint( clrs.get((int)waveMap,0), 255 );

				buildCube(tex[0], tex[1], tex[2], tex[3], tex[4], tex[5]);
			pop();
		}
	pop();

	push();
		translate((stageW/2)-(roseWindow.width/2), (stageH/2)-(roseWindow.height/2), 0);
		//perspective(PI/3.0, (float)(width*2)/(height*2), 0.1, 1000000);
		hint(DISABLE_DEPTH_TEST);
		strokeWeight(0);
		noStroke();
		fill(0xFFFF3300, 245);
		// ellipse(0, 0, 300, 300);
		image(roseWindow, startRosPosX,startRosPosY);
		for (int i = 0; i < 10000; ++i)  {
			rotate(radians(i));
		}
		hint(ENABLE_DEPTH_TEST);
	pop();
} 
// *********************************************************************************************

int         numAssets2      = 25;

HOrbiter3D[] orb = new HOrbiter3D[numAssets2];

int          orbStartX = 0;
int          orbStartY = 0;
int          orbStartZ = 0;

float        orbZ_SpeedMin = 0.5f;
float        orbZ_SpeedMax = 1.5f;

float        orbY_SpeedMin = 0.1f;
float        orbY_SpeedMax = 0.5f;

int          orbRadius  = 700;

// *********************************************************************************************

HOscillator[] oscS2         = new HOscillator[numAssets2];

// *********************************************************************************************

int[]       myPickedAudio2  = new int[numAssets2];

// *********************************************************************************************


 public void drawPyreflies() {
	//background( clrBG );

// ************************************************************************************
	//lights();

	hint(DISABLE_DEPTH_TEST);


	push();
		translate(stageW/2, stageH/2, 0);
		perspective(PI/3.0f, (float)(width*2)/(height*2), 0.1f, 1000000);

		for (int i = 0; i < numAssets2; ++i) {

			HOscillator _oscS2 = oscS2[i];
			float _aS2 = map(myAudioData[ myPickedAudio2[i] ], 0, myAudioMax, 0.0f, 2.0f);
			_oscS2.speed(_aS2);
			_oscS2.nextRaw(); 

			HOrbiter3D _orb = orb[i];

			float _orbZ = map(myAudioData[ myPickedAudio2[i] ], 0, myAudioMax, orbZ_SpeedMin, orbZ_SpeedMax);
			// float _orbY = map(myAudioData[ myPickedAudio[i] ], 0, myAudioMax, orbY_SpeedMin, orbY_SpeedMax);
			// _orb.zSpeed( _orbZ ).ySpeed( _orbY );

			_orb._run();
			PVector pt = _orb.getNextPoint();

			push();
				translate(pt.x, pt.y, pt.z );
				scale(_oscS2.curr());

				float wave2 = sin( clrCount2+(i*clrOffset2) );
				float waveMap2 = map(wave2, -1, 1, 0, clrsW2);
				tint( clrs2.get((int)waveMap2,0), 255 );

				buildCube2(tex2[0], tex2[0], tex2[0], tex2[0], tex2[0], tex2[0]);
			pop();
		}
	pop();

// ************************************************************************************

	noLights();
	audioUpdate();
	strokeWeight(0);
	noStroke();
	fill(0xFF000000, 10);
	rect(0,0,stageW,stageH);
}

 public void buildCube2(PImage _t1, PImage _t2, PImage _t3, PImage _t4, PImage _t5, PImage _t6) {
	strokeWeight(0);
	noStroke();

	// back
	beginShape(QUADS);
		texture(_t1);
		vertex( (0.5f), -(0.5f), -(0.5f),   0, 0);
		vertex(-(0.5f), -(0.5f), -(0.5f),   1, 0);
		vertex(-(0.5f),  (0.5f), -(0.5f),   1, 1);
		vertex( (0.5f),  (0.5f), -(0.5f),   0, 1);
	endShape(CLOSE);

	/*// left
	beginShape(QUADS);
		texture(_t2);
		vertex(-(0.5), -(0.5), -(0.5),   0, 0);
		vertex(-(0.5), -(0.5),  (0.5),   1, 0);
		vertex(-(0.5),  (0.5),  (0.5),   1, 1);
		vertex(-(0.5),  (0.5), -(0.5),   0, 1);
	endShape(CLOSE);

	// right
	beginShape(QUADS);
		texture(_t3);
		vertex( (0.5), -(0.5),  (0.5),   0, 0);
		vertex( (0.5), -(0.5), -(0.5),   1, 0);
		vertex( (0.5),  (0.5), -(0.5),   1, 1);
		vertex( (0.5),  (0.5),  (0.5),   0, 1);
	endShape(CLOSE);

	// top
	beginShape(QUADS);
		texture(_t4);
		vertex(-(0.5), -(0.5), -(0.5),   0, 0);
		vertex( (0.5), -(0.5), -(0.5),   1, 0);
		vertex( (0.5), -(0.5),  (0.5),   1, 1);
		vertex(-(0.5), -(0.5),  (0.5),   0, 1);
	endShape(CLOSE);

	// bottom
	beginShape(QUADS);
		texture(_t5);
		vertex(-(0.5),  (0.5),  (0.5),   0, 0);
		vertex( (0.5),  (0.5),  (0.5),   1, 0);
		vertex( (0.5),  (0.5), -(0.5),   1, 1);
		vertex(-(0.5),  (0.5), -(0.5),   0, 1);
	endShape(CLOSE);

	// front
	beginShape(QUADS);
		texture(_t6);
		vertex(-(0.5), -(0.5),  (0.5),   0, 0); // x, y, z, u, v
		vertex( (0.5), -(0.5),  (0.5),   1, 0); // x, y, z, u, v
		vertex( (0.5),  (0.5),  (0.5),   1, 1); // x, y, z, u, v
		vertex(-(0.5),  (0.5),  (0.5),   0, 1); // x, y, z, u, v
	endShape(CLOSE);*/
}
// ************************************************************************************

// THIS IS THE VARS FOR THE RECTS IN THE VISUALIZER

float visX = 1.0f;
float visY = 1.0f;
float visW = ((PApplet.parseFloat(stageW)-(visX*2))-(PApplet.parseFloat(myAudioRange)-1)) / PApplet.parseFloat(myAudioRange);
float visH = 2.0f;
float visS = (PApplet.parseFloat(stageW)-(visX*2)) / PApplet.parseFloat(myAudioRange);

// ************************************************************************************

 public void audioSetup() {
	switch (myAudioRange) {
		case 16 :
			myAudioAmp       = 40.0f;
			myAudioIndex     = 0.2f;
			myAudioIndexStep = 0.30f;
			break;
		case 32 :
			myAudioAmp       = 30.0f;
			myAudioIndex     = 0.17f;
			myAudioIndexStep = 0.225f;
			break;
		case 64 :
			myAudioAmp       = 25.0f;
			myAudioIndex     = 0.125f;
			myAudioIndexStep = 0.175f;
			break;
		case 128 :
			myAudioAmp       = 30.0f;
			myAudioIndex     = 0.075f;
			myAudioIndexStep = 0.05f;
			break;
		case 256 : default :
			myAudioAmp       = 20.0f;
			myAudioIndex     = 0.05f;
			myAudioIndexStep = 0.025f;
			break;
	}
	myAudioIndexAmp  = myAudioIndex;

	minim = new Minim(this);

	if (myAudioToggle) {
		myAudioPlayer = minim.loadFile(pathAssets + whichAudioFile);
		myAudioPlayer.loop();
		//myAudioPlayer.mute();
		myAudioFFT = new FFT(myAudioPlayer.bufferSize(), myAudioPlayer.sampleRate());
		myAudioFFT.linAverages(myAudioRange);
		myAudioFFT.window(FFT.GAUSS);
	} else {
		myAudioInput = minim.getLineIn(Minim.MONO);
		myAudioFFT = new FFT(myAudioInput.bufferSize(), myAudioInput.sampleRate());
		myAudioFFT.linAverages(myAudioRange);
		myAudioFFT.window(FFT.NONE);
	}

}

// ************************************************************************************

 public void audioUpdate() {
	hint(DISABLE_DEPTH_TEST);
	noLights();
	perspective(PI/3.0f, (float)(width*2)/(height*2), 0.1f, 1000000);

	if (myAudioToggle) myAudioFFT.forward(myAudioPlayer.mix);
	else               myAudioFFT.forward(myAudioInput.mix);

	if(showVisualizer) {
		strokeWeight(0);
		noStroke();
		fill(0xFF000000, 245);
		rect(visX, visY, stageW, myAudioMax+30);
	}

	for (int i = 0; i < myAudioRange; ++i) {
		strokeWeight(0);
		noStroke();

		float tempIndexAvg = (myAudioFFT.getAvg(i) * myAudioAmp) * myAudioIndexAmp;
		myAudioIndexAmp+=myAudioIndexStep;
		float tempIndexCon = constrain(tempIndexAvg, 0, myAudioMax);
		myAudioData[i]     = tempIndexCon; // RECODE THE NUMBERS FROM - 0 TO 100

		if (showVisualizer) {
			if(tempIndexCon<=visH)                         fill(0xFF333333); // NO AUDIO
			else if(tempIndexCon>visH && tempIndexCon<=10) fill(0xFF2EA893); // visH to 10
			else if(tempIndexCon>10 && tempIndexCon<=20)   fill(0xFF64BE7A); // 11 to 20
			else if(tempIndexCon>20 && tempIndexCon<=30)   fill(0xFF9AD561); // 21 to 30
			else if(tempIndexCon>30 && tempIndexCon<=40)   fill(0xFFCCEA4A); // 31 to 40
			else if(tempIndexCon>40 && tempIndexCon<=50)   fill(0xFFFFFF33); // 41 to 50
			else if(tempIndexCon>50 && tempIndexCon<=60)   fill(0xFFF8EF33); // 51 to 60
			else if(tempIndexCon>60 && tempIndexCon<=70)   fill(0xFFFFC725); // 61 to 70
			else if(tempIndexCon>70 && tempIndexCon<=80)   fill(0xFFFF9519); // 71 to 80
			else if(tempIndexCon>80 && tempIndexCon<=90)   fill(0xFFFF620C); // 81 to 90
			else                                           fill(0xFFFF3300); // 91 to 100

			rect( visX + (i*visS), ((visY-(visH/2))+(myAudioMax/2))-(tempIndexCon/2), visW, visH+tempIndexCon);

			textSize(14);
			text( (int)myAudioData[i], visX + (i*visS), visY+(myAudioMax+20) );

			strokeWeight(1);
			stroke(0xFF666666);
			noFill();
			line(0, visY, stageW, visY);
			line(0, visY+myAudioMax, stageW, visY+myAudioMax);
			line(0, visY+(myAudioMax+30), stageW, visY+(myAudioMax+30));
		}
	}
	myAudioIndexAmp = myAudioIndex;
	hint(ENABLE_DEPTH_TEST);
}

// ************************************************************************************

 public void stop() {
	if (myAudioToggle) myAudioPlayer.close();
	else               myAudioInput.close();
	minim.stop();  
	super.stop();
}

// ************************************************************************************


  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "build" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
