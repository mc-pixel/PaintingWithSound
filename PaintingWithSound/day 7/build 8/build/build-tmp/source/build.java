/* autogenerated by Processing revision 1283 on 2022-07-28 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import ddf.minim.*;
import ddf.minim.analysis.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class build extends PApplet {

int         stageW           = 1000;
int         stageH           = 1000;
int       clrBG            = 0xFF242424;
String      pathAssets       = "../../../assets/";

// ************************************************************************************

// THIS IS THE AUDIO VARS




Minim       minim;
AudioPlayer myAudioPlayer;
String 		whichAudioFile 	 = "AUDIO.wav";
AudioInput  myAudioInput;
boolean     myAudioToggle    = true; // true = myAudioPlayer / false = myAudioInput
boolean 	showVisualizer 	 = true;

FFT         myAudioFFT;

int         myAudioRange     = 16; //256 /128(2) / 64(4) / 32(8) / 16(16)
int         myAudioMax       = 100;


float       myAudioAmp       =40.0f;
float       myAudioIndex     = 0.2f;
float       myAudioIndexAmp  = myAudioIndex;
float       myAudioIndexStep = 0.30f;
float[]		myAudioData		 = new float[myAudioRange];//keeps a reord of all the numbers in an array

// ************************************************************************************

// THIS IS THE VARS FOR THE RECTS

float       artX             = 1.0f;
float       artY             = 1.0f;
float       artW             = ((PApplet.parseFloat(stageW)-(artX*2))-(PApplet.parseFloat(myAudioRange)-1)) / PApplet.parseFloat(myAudioRange);
float 		artH 			 = 2.0f;
float       artSpacing       = (PApplet.parseFloat(stageW)-(artX*2)) / PApplet.parseFloat(myAudioRange);

// ************************************************************************************

 public void settings() {
	size(stageW, stageH, P3D);
}

 public void setup() {
	background(clrBG);
	audioSetup();
}

 public void draw() {
	background(clrBG);
	audioUpdate();

	lights();
	strokeWeight(0);
	noStroke();
	fill(0xFF00FF00);

	push();
		translate(stageW/2 , stageH/2,0);
		rotateX(radians((int)map(myAudioData[3],0,myAudioMax,-180,180)));
		rotateY(radians((int)map(myAudioData[6],0,myAudioMax,-180,180)));
		rotateZ(radians((int)map(myAudioData[9],0,myAudioMax,-180,180)));
		int boxScale = (int)map(myAudioData[0],0,myAudioMax, 50, 500);
		box(boxScale, boxScale, boxScale);
	pop();


}

// ************************************************************************************

 public void keyPressed() {
	switch (key) {

		case '1': myAudioToggle = true;  if(!myAudioToggle){myAudioInput.close();}  minim.stop(); audioSetup(); break; //audioPlayer
		case '2': myAudioToggle = false; myAudioPlayer.close(); minim.stop(); audioSetup(); break; //audioInput

		case 's': myAudioPlayer.pause();  break;
		case 'p': myAudioPlayer.play();   break;
		case 'm': myAudioPlayer.mute();   break;
		case 'u': myAudioPlayer.unmute(); break;

		case 'v': showVisualizer = !showVisualizer; break;
	}
}
// ************************************************************************************

 public void audioSetup() {
	minim = new Minim(this);

	if (myAudioToggle) {
		myAudioPlayer = minim.loadFile(pathAssets + whichAudioFile);
		myAudioPlayer.loop();
		myAudioPlayer.mute();
		myAudioFFT = new FFT(myAudioPlayer.bufferSize(), myAudioPlayer.sampleRate());
		myAudioFFT.linAverages(myAudioRange);
	} else {
		myAudioInput = minim.getLineIn(Minim.MONO);
		myAudioFFT = new FFT(myAudioInput.bufferSize(), myAudioInput.sampleRate());
		myAudioFFT.linAverages(myAudioRange);
	}
	myAudioFFT.window(FFT.GAUSS);
}
// ************************************************************************************

 public void audioUpdate(){

	if (myAudioToggle) myAudioFFT.forward(myAudioPlayer.mix);
	else               myAudioFFT.forward(myAudioInput.mix);

		if(showVisualizer){
			strokeWeight(0);
			noStroke();
			fill(0xFF000000,245);
			rect(artX,artY,stageW,myAudioMax+30);
		}
	for (int i = 0; i < myAudioRange; ++i) {
			strokeWeight(0);
			//stroke(#000000);
			noStroke();
			fill(0xFFFFFFFF);
		float tempIndexAvg = (myAudioFFT.getAvg(i) * myAudioAmp) * myAudioIndexAmp;
		myAudioIndexAmp+=myAudioIndexStep;
		float tempIndexCon = constrain(tempIndexAvg, 0, myAudioMax);
		myAudioData[i]	   = tempIndexCon; //record the numbers from 0 - 100
		if(showVisualizer){
			if(tempIndexCon<=artH) fill(0xFF0095A8);
			else 				   fill(0xFFFFFFFF);
			rect( artX + (i*artSpacing), (artY - (artH / 2) + (myAudioMax / 2)) - (tempIndexCon/2), artW,artH+tempIndexCon);

			strokeWeight(0);
			noStroke();
			fill(0xFF0095A8);
			textSize(14);
			text((int)myAudioData[i],artX + (i*artSpacing), artY+(myAudioMax+20));
		}
	}
	myAudioIndexAmp = myAudioIndex;

	if(showVisualizer){
		strokeWeight(1);
		stroke(0xFFFF3300);
		noFill();
		line(0, artY, stageW, artY);
		line(0, artY+myAudioMax, stageW, artY+myAudioMax);
	}
}

// ************************************************************************************

 public void stop() {
	if (myAudioToggle) myAudioPlayer.close();
	else               myAudioInput.close();
	minim.stop();  
	super.stop();
}

// ************************************************************************************


  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "build" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
